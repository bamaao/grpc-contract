// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.

// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

package main

import (
	"bytes"
	"fmt"
	"html/template"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"sort"
	"strings"

	"github.com/ethereum/go-ethereum/accounts/abi"
	flag "github.com/spf13/pflag"

	"github.com/getamis/sirius/util"
	"github.com/getamis/sol2proto/grpc"
)

var (
	abiFiles []string
	pkgName  string
)

func init() {
	flag.StringArrayVar(&abiFiles, "abi", []string{}, "ABI files generated by solc")
	flag.StringVar(&pkgName, "pkg", "p", "go package name for the generated proto")
}

func main() {
	flag.Parse()

	if len(abiFiles) == 0 {
		fmt.Printf("Please specify the abi files\n")
		os.Exit(-1)
	}

	if pkgName == "" {
		fmt.Printf("Please specify package name\n")
		os.Exit(-1)
	}

	// generate messages proto file
	messages := grpc.Service{
		Package:  pkgName,
		Name:     "Messages",
		Messages: make(map[string]grpc.Message),
		Sources:  make([]string, len(abiFiles)),
	}

	for i, f := range abiFiles {
		abiString, err := ioutil.ReadFile(f)
		if err != nil {
			fmt.Printf("Failed to read input ABI: %v\n", err)
			os.Exit(-1)
		}

		contractAbi, err := abi.JSON(bytes.NewReader(abiString))
		if err != nil {
			fmt.Printf("Failed to parse contract ABI: %v\n", err)
			os.Exit(-1)
		}

		srvName := util.ToCamelCase(strings.TrimSuffix(filepath.Base(f), filepath.Ext(filepath.Base(f))))
		_, source := path.Split(f)
		messages.Sources[i] = source
		service := grpc.Service{
			Package: pkgName,
			Name:    srvName,
			Sources: []string{source},
		}

		for _, f := range contractAbi.Methods {
			var inputArgs []grpc.Argument
			var outputArgs []grpc.Argument
			method := grpc.Method{
				Const: f.Const,
				Name:  f.Name,
			}

			// If it is not a const method, we need to provide
			// more transaction options to send transactions.
			if !f.Const {
				inputArgs = append(inputArgs, grpc.Argument{
					Name:    "opts",
					Type:    grpc.TransactOptsReq.Name,
					IsSlice: false,
				})
			}

			for _, input := range f.Inputs {
				arg := grpc.ToGrpcArgument(input)
				method.Inputs = append(method.Inputs, arg)
				inputArgs = append(inputArgs, arg)
			}

			for _, output := range f.Outputs {
				arg := grpc.ToGrpcArgument(output)
				method.Outputs = append(method.Outputs, arg)
				outputArgs = append(outputArgs, arg)
			}

			if len(inputArgs) > 0 {
				inMsg := grpc.ToMessage(method.RequestName(), inputArgs)
				messages.Messages[inMsg.Name] = inMsg
			}

			if len(outputArgs) > 0 {
				outMsg := grpc.ToMessage(method.ResponseName(), outputArgs)
				messages.Messages[outMsg.Name] = outMsg
			}
			service.Methods = append(service.Methods, method)
		}

		for i, ev := range contractAbi.Events {
			method := grpc.Method{}

			if ev.Anonymous {
				method.Name = fmt.Sprintf("onEvent%s", i)
			} else {
				method.Name = "on" + ev.Name
			}

			for _, in := range ev.Inputs {
				arg := grpc.ToGrpcArgument(in)
				method.Inputs = append(method.Inputs, arg)
			}

			if len(method.Inputs) > 0 {
				inMsg := grpc.ToMessage(method.RequestName(), method.Inputs)
				messages.Messages[inMsg.Name] = inMsg
			}

			service.Events = append(service.Events, method)
		}
		sort.Sort(service.Methods)
		sort.Sort(service.Events)
		sort.Sort(service.Sources)
		writeServiceToFile(srvName, grpc.ServiceTemplate, service)
	}
	sort.Sort(messages.Sources)
	writeServiceToFile(messages.Name, grpc.MessagesTemplate, messages)
}

// writeServiceToFile writes the service into file
func writeServiceToFile(srvName, serviceTemplate string, service interface{}) {
	template, err := template.New("proto").Parse(serviceTemplate)
	if err != nil {
		fmt.Printf("Failed to parse template: %v\n", err)
		os.Exit(-1)
	}

	filename := fmt.Sprintf("%v.proto", util.ToUnderScore(srvName))
	file, err := os.Create(filename)
	if err != nil {
		fmt.Printf("Failed to create file: %v, %v\n", filename, err)
		os.Exit(-1)
	}
	err = template.Execute(file, service)
	if err != nil {
		fmt.Printf("Failed to render template: %v\n", err)
		os.Exit(-1)
	}
}
